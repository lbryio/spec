<!DOCTYPE html>
<html>
<head>
  <title></title>
  <meta name="GENERATOR" content="github.com/mmarkdown/mmark Mmark Markdown Processor - mmark.nl">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" type="text/css" href="normalize.css">
  <link rel="stylesheet" type="text/css" href="tocbot.css">
  <link rel="stylesheet" type="text/css" href="style.css">
  <script src="tocbot.min.js"></script>
  <script>
    function ready(fn) {
      if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading"){
        fn();
      } else {
        document.addEventListener('DOMContentLoaded', fn);
      }
    }

    function toggleClass(el, className) {
      if (el.classList) {
        el.classList.toggle(className);
      } else {
        var classes = el.className.split(' ');
        var existingIndex = classes.indexOf(className);

        if (existingIndex >= 0)
          classes.splice(existingIndex, 1);
        else
          classes.push(className);

        el.className = classes.join(' ');
      }
    }

    ready(function() {
      var options = {
        tocSelector: '.toc',
        contentSelector: '#content',
        headingSelector: 'h2, h3, h4, h5, h6',
        collapseDepth: 3,
        positionFixedSelector: ".toc",
      };

      tocbot.init(options);

      document.querySelector('.toc-menu').addEventListener("click", function() {
        toggleClass(document.querySelector('.toc'), "open");
      });
      
      
      // need this part to fix toc offset height if content above toc changes height
      var resizeTimer;
      window.addEventListener('resize', function(e) {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(function() {
          o = options;
          o.fixedSidebarOffset = "auto"; 
          tocbot.refresh(o);
        }, 250);
      });


    })
  </script></head>
<body>

<p><main></p>

<h1 id="lbry-a-decentralized-digital-content-marketplace">LBRY: A Decentralized Digital Content Marketplace</h1>

<p><div class="toc-menu">Menu</div>
<nav class="toc"></nav>
<div id="content"></p>

<noscript>

## Table of Contents
 
<!-- this TOC is autogenerated for github preview or js-challenged browsers -->

<!--ts-->
* [Introduction](#introduction)
   * [Overview](#overview)
   * [Assumptions](#assumptions)
   * [Conventions and Terminology](#conventions-and-terminology)
* [Blockchain](#blockchain)
   * [Stakes](#stakes)
      * [Claims](#claims)
         * [Claim Properties](#claim-properties)
         * [Example Claim](#example-claim)
         * [Claim Operations](#claim-operations)
      * [Supports](#supports)
         * [Support Properties](#support-properties)
         * [Example Support](#example-support)
         * [Support Operations](#support-operations)
      * [Claimtrie](#claimtrie)
      * [Statuses](#stake-statuses)
         * [Accepted](#accepted)
         * [Abandoned](#abandoned)
         * [Active](#active)
         * [Controlling (claims only)](#controlling)
      * [Activation Delay](#activation-delay)
      * [Claim Ordering](#claim-ordering)
      * [Normalization](#normalization)
   * [URLs](#urls)
      * [Components](#components)
         * [Stream Claim Name](#stream-claim-name)
         * [Channel Claim Name](#channel-claim-name)
         * [Channel Claim Name and Stream Claim Name](#channel-claim-name-and-stream-claim-name)
         * [Claim ID](#claim-id)
         * [Claim Sequence](#claim-sequence)
         * [Bid Position](#bid-position)
         * [Query Params](#query-params)
      * [Grammar](#grammar)
      * [Resolution](#resolution)
         * [No Modifier](#no-modifier)
         * [ClaimID](#claimid)
         * [ClaimSequence](#claimsequence)
         * [BidPosition](#bidposition)
         * [ChannelClaimName and StreamClaimName](#channelclaimname-and-streamclaimname)
      * [Design Notes](#design-notes)
   * [Transactions](#transactions)
      * [Operations and Opcodes](#operations-and-opcodes)
         * [Claim Identifier Generation](#claim-identifier-generation)
         * [OP_CLAIM_NAME](#op-claim-name)
         * [OP_UPDATE_CLAIM](#op-update-claim)
         * [OP_SUPPORT_CLAIM](#op-support-claim)
      * [Tips](#tips)
      * [Proof of Payment](#proof-of-payment)
   * [Consensus](#consensus)
      * [Block Timing](#block-timing)
      * [Difficulty Adjustment](#difficulty-adjustment)
      * [Block Hash Algorithm](#block-hash-algorithm)
      * [Block Rewards](#block-rewards)
      * [Addresses](#addresses)
* [Metadata](#metadata)
   * [Specification](#specification)
      * [Example](#metadata-example)
   * [Key Fields](#key-fields)
      * [Stream Hash](#stream-hash)
      * [Fee](#fee)
      * [Title, Author, Description](#title-author-description)
      * [Language](#language)
      * [Thumbnail](#thumbnail)
      * [Media Type](#media-type)
   * [Channels (Identities)](#channels)
      * [Signing](#signing)
         * [Format Versions](#format-versions)
         * [Signing Process](#signing-process)
         * [Signature Validation](#signature-validation)
   * [Validation](#metadata-validation)
* [Data](#data)
   * [Encoding](#encoding)
      * [Blobs](#blobs)
      * [Streams](#streams)
      * [Manifest Contents](#manifest-contents)
      * [Stream Encoding](#stream-encoding)
         * [Setup](#setup)
         * [Content Blobs](#content-blobs)
         * [Manifest Blob](#manifest-blob)
      * [Stream Decoding](#stream-decoding)
   * [Announce](#announce)
      * [Distributed Hash Table](#distributed-hash-table)
      * [Announcing to the DHT](#announcing-to-the-dht)
   * [Download](#download)
      * [Querying the DHT](#querying-the-dht)
      * [Blob Exchange Protocol](#blob-exchange-protocol)
         * [PriceCheck](#pricecheck)
         * [DownloadCheck](#downloadcheck)
         * [Download](#download-1)
         * [UploadCheck](#uploadcheck)
         * [Upload](#upload)
   * [Reflectors and Data Markets](#reflectors-and-data-markets)
* [Appendix](#appendix)
   * [Claim Activation Example](#claim-activation-example)
   * [URL Resolution Examples](#url-resolution-examples)
<!--te-->

</noscript>

<!-- 
fixme final polish checklist:

- go over the paper to make sure we use active voice in most places (though passive is better sometimes)
- standardize when we say "we do X" vs "LBRY does X"
- check that all anchors work
- check css across browsers/mobile
- create links for [[terms]]
- ensure that all italicized terms are defined before they are used, or if that doesn't work, that they are linked
- don't say "the LBRY network". instead say "LBRY" or say nothing.

-->

<h2 id="introduction">Introduction</h2>

<p>LBRY is a protocol for accessing and publishing digital content in a global, decentralized marketplace. Clients can use LBRY to publish, host, find, download, and pay for content — books, movies, music, or anything else that can be represented as a stream of bits. Participation in the network is open to everyone. No permission is required, and no one may be blocked from participating. The system is distributed, so no single entity has unilateral control, nor will the removal of any single entity prevent the system from functioning.</p>

<p>TODO:</p>

<ul>
<li>why is it significant</li>
<li>whom does it help</li>
<li>why is it different/better than what existed before</li>
</ul>

<h3 id="overview">Overview</h3>

<p>This document defines the LBRY protocol, its components, and how they fit together. LBRY consists of several discrete components that are used together in order to provide the end-to-end capabilities of the protocol. There are two distributed data stores (blockchain and DHT), a peer-to-peer protocol for exchanging data, and specifications for data structure, encoding, and retrieval.</p>

<h3 id="assumptions">Assumptions</h3>

<p>This document assumes that the reader is familiar with Bitcoin and blockchain technology. It does not attempt to document the Bitcoin protocol or explain how it works. The <a href="https://bitcoin.org/en/developer-reference">Bitcoin developer reference</a> is recommended for anyone wishing to understand the technical details.</p>

<h3 id="conventions-and-terminology">Conventions and Terminology</h3>

<dl>
  <dt>blob</dt>
  <dd>The unit of data transmission on the data network. A published file is split into many blobs.</dd>

  <dt>stream</dt>
  <dd>A set of blobs that can be reassembled into a file. Every stream has one or more content blobs which contain the published file, and a manifest blob which contains a list of the content blob hashes.</dd>

  <dt>blob hash</dt>
  <dd>The cryptographic hash of a blob. Hashes are used to uniquely identify blobs and to verify that the contents of the blob are correct. Unless otherwise specified, LBRY uses [SHA-384](https://en.wikipedia.org/wiki/SHA-2) as the hash function.</dd>

  <dt>metadata</dt>
  <dd>Information about the contents of a stream (e.g. creator, description, stream hash, etc). Metadata is stored in the blockchain.</dd>

  <dt>name</dt>
  <dd>A human-readable UTF8 string that is associated with a claim.</dd>

  <dt>stake</dt>
  <dd>An entry in the blockchain that sets aside some credits and associates them with a name.</dd>

  <dt>claim</dt>
  <dd>A stake that contains metadata about a stream or channel.</dd>

  <dt>support</dt>
  <dd>A stake that lends its credits to bolster a claim.</dd>

  <dt>channel</dt>
  <dd>The unit of pseudonymous publisher identity. Claims may be part of a channel.</dd>

  <dt>URL</dt>
  <dd>A memorable reference to a claim.</dd>
</dl>

<h2 id="blockchain">Blockchain</h2>

<p>The LBRY blockchain is a public, proof-of-work blockchain. It serves three key purposes:</p>

<ol>
<li>An index of the content available on the network</li>
<li>A payment system and record of purchases for priced content</li>
<li>Cryptographic publisher identities</li>
</ol>

<p>The LBRY blockchain is a fork of the <a href="https://bitcoin.org/bitcoin.pdf">Bitcoin</a> blockchain, with substantial modifications. This document does not cover or specify any aspects of LBRY that are identical to Bitcoin, and instead focuses on the differences.</p>

<h3 id="stakes">Stakes</h3>

<p>A <em>stake</em> is a a single entry in the blockchain that commits credits toward a name. The two types of stakes are <a href="#claims"><em>claims</em></a> and <a href="#supports"><em>supports</em></a>.</p>

<p>All stakes have these properties:</p>

<dl>
  <dt>id</dt>
  <dd>A 20-byte hash unique among all stakes. See <a href="#stake-identifier-generation">Stake Identifier Generation</a>.</dd>
  <dt>amount</dt>
  <dd>A quantity of tokens used to back the stake. See <a href="#controlling">Controlling</a>.</dd>
</dl>

<h4 id="claims">Claims</h4>

<p>A <em>claim</em> is a stake that stores metadata. There are two types of claims:</p>

<dl>
  <dt>stream claim</dt>
  <dd>Declares the availability, access method, and publisher of a [[stream]].</dd>
  <dt>channel claim</dt>
  <dd>Creates a pseudonym that can be declared as the publisher of stream claims.</dd>
</dl>

<h5 id="claim-properties">Claim Properties</h5>

<p>In addition to the properties that all stakes have, claims have two more properties:</p>

<dl>
  <dt>name</dt>
  <dd>A normalized UTF-8 string of up to 255 bytes used to address the claim. See <a href="#urls">URLs</a>.</dd>
  <dt>value</dt>
  <dd>Metadata about a stream or a channel. See <a href="#metadata">Metadata</a>.</dd>
</dl>
  

<h5 id="example-claim">Example Claim</h5>

<p>Here is an example stream claim:</p>
<figure>
<pre><code>{
  &quot;claimID&quot;: &quot;6e56325c5351ceda2dd0795a30e864492910ccbf&quot;,
  &quot;amount&quot;: 1.0,
  &quot;name&quot;: &quot;lbry&quot;,
  &quot;value&quot;: {
    &quot;stream&quot;: {
      &quot;title&quot;: &quot;What is LBRY?&quot;,
      &quot;author&quot;: &quot;Samuel Bryan&quot;,
      &quot;description&quot;: &quot;What is LBRY? An introduction with Alex Tabarrok&quot;,
      &quot;language&quot;: &quot;en&quot;,
      &quot;license&quot;: &quot;Public Domain&quot;,
      &quot;thumbnail&quot;: &quot;https://s3.amazonaws.com/files.lbry.io/logo.png&quot;,
      &quot;mediaType&quot;: &quot;video/mp4&quot;,
      &quot;streamHash&quot;: &quot;232068af6d51325c4821ac897d13d7837265812164021ec832cb7f18b9caf6c77c23016b31bac9747e7d5d9be7f4b752&quot;,
    },
  }
}
</code></pre>
<figcaption>Note: the blockchain treats the <code>value</code> as an opaque byte string and does not impose any structure on it. Structure is applied and validated <a href="#metadata-validation">higher in the stack</a>. The value is shown here for demonstration purposes only.
</figcaption>
</figure>

<h5 id="claim-operations">Claim Operations</h5>

<p>There are three claim operations: <em>create</em>, <em>update</em>, and <em>abandon</em>.</p>

<dl>
  <dt>create</dt>
  <dd>Makes a new claim.</dd>
  <dt>update</dt>
  <dd>Changes the value or amount of an existing claim, without changing the claim ID.</dd>
  <dt>abandon</dt>
  <dd>Withdraws a claim, freeing the associated credits to be used for other purposes.</dd>
</dl>

<h4 id="supports">Supports</h4>

<p>A <em>support</em> is a stake that lends its amount to an existing claim.</p>

<h5 id="support-properties">Support Properties</h5>

<p>Supports have one extra property in addition to the stake properties:</p>

<dl>
  <dt>claimID</dt>
  <dd>The ID of the claim that this support is bolstering.</dd>
</dl>

<h5 id="example-support">Example Support</h5>

<p>Here is an example support for the above claim:</p>

<pre><code>{
  &quot;supportID&quot;: &quot;fbcc019294468e03a5970dd2adec1535c52365e6&quot;,
  &quot;amount&quot;: 45.12,
  &quot;claimID&quot;: &quot;6e56325c5351ceda2dd0795a30e864492910ccbf&quot;,
}
</code></pre>

<h5 id="support-operations">Support Operations</h5>

<p>Supports are created and abandoned just like claims (see <a href="#claim-operations">Claim Operations</a>). Supports cannot be updated or themselves supported.</p>

<h4 id="claimtrie">Claimtrie</h4>

<p>A <em>claimtrie</em> is a data structure used to store the set of all claims and prove the correctness of claim resolution.</p>

<p>The claimtrie is implemented as a <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle tree</a> that maps names to claims. Claims are stored as leaf nodes in the tree. Names are stored as the <a href="#normalization">normalized</a> path from the root node to the leaf node.</p>

<p>The <em>root hash</em> is the hash of the root node. It is stored in the header of each block in the blockchain. Nodes use the root hash to efficiently and securely validate the state of the claimtrie.</p>

<p>Multiple claims can exist for the same name. They are all stored in the leaf node for that name. See <a href="#claim-ordering">Claim Ordering</a></p>

<p>For more details on the specific claimtrie implementation, see <a href="https://github.com/lbryio/lbrycrd/blob/master/src/claimtrie.cpp">the source code</a>.</p>

<h4 id="stake-statuses">Statuses</h4>

<p>Stakes can have one or more of the following statuses at a given block.</p>

<h5 id="accepted">Accepted</h5>

<p>An <em>accepted</em> stake is one that has been been entered into the blockchain. This happens when the transaction containing it is included in a block.</p>

<p>Accepted stakes do not affect the intra-leaf claim order until they are <a href="#active">active</a>.</p>

<p>The sum of the amount of a claim stake and all of its accepted supports is called its <em>total amount</em>.</p>

<h5 id="abandoned">Abandoned</h5>

<p>An <em>abandoned</em> stake is one that was withdrawn by its owner. Spending a transaction that contains a stake will cause that claim to become abandoned. Abandoned claim stakes are removed from the claimtrie.</p>

<p>While data related to abandoned stakes still resides in the blockchain, it is considered invalid and should not be used to resolve URLs or fetch the associated content. Active claim stakes signed by abandoned identities are also considered invalid.</p>

<h5 id="active">Active</h5>

<p>An <em>active</em> stake is an accepted and non-abandoned stake that has been in the blockchain for an algorithmically determined number of blocks. This length of time required is called the <em>activation delay</em>.</p>

<p>If the stake is an update to an active claim, is the only accepted non-abandoned claim for a name, or does not cause a change in which claim is controlling the name, the activation delay is 0 (i.e. the stake becomes active immediately).</p>

<p>Otherwise, the activation delay is determined by a formula covered in <a href="#activation-delay">Activation Delay</a>. The formula&rsquo;s inputs are the height of the current block, the height at which the stake was accepted, and the height at which the controlling claim for that name last changed.</p>

<p>The sum of the amount of an active claim and all of its active supports is called its <em>effective amount</em>. The effective amount affects the sort order of claims in a leaf node, and which claim is controlling for that name. Claims that are not active have an effective amount of 0.</p>

<h5 id="controlling">Controlling (claims only)</h5>

<p>A <em>controlling</em> claim is the active claim that is first in the sort order of a leaf node. That is, it has the highest effective amount of all claims with the same name.</p>

<p>Only one claim can be controlling for a given name at a given block.</p>

<h4 id="activation-delay">Activation Delay</h4>

<p>If a stake does not become active immediately, it becomes active at the block height determined by the following formula:</p>

<pre><code>ActivationHeight = AcceptedHeight + min(4032, floor( (AcceptedHeight-TakeoverHeight)/32 ))
</code></pre>

<p>Where:</p>

<ul>
<li><code>AcceptedHeight</code> is the height when the stake was accepted</li>
<li><code>TakeoverHeight</code> is the most recent height at which the controlling claim for the name changed</li>
</ul>

<p>In written form, the delay before a stake becomes active is equal to the height at which the stake was accepted minus height of the last takeover, divided by 32. This delay is capped at a maximum of 4032 blocks, which is 7 days of blocks at 2.5 minutes per block (our target block time). It takes approximately 224 days without a takeover to reach the max delay.</p>

<p>The purpose of this delay is to give long-standing claimants time to respond to changes, while still keeping takeover times reasonable and allowing recent or contentious claims to change state quickly.</p>

<h4 id="claim-ordering">Claim Ordering</h4>

<p>To determine the order of claims in a leaf node, the following algorithm is used:</p>

<ol>
<li><p>For each claim, recalculate the effective amount.</p></li>

<li><p>Sort the claims by effective amount in descending order. Claims tied for the same amount are ordered by block height (lowest first), then by transaction order within the block.</p></li>

<li><p>If the controlling claim from the previous block is still first in the order, then the ordering is finished.</p></li>

<li><p>Otherwise, a takeover is occurring. Set the takeover height for this name to the current height, recalculate which stakes are now active, and redo steps 1 and 2.</p></li>

<li><p>At this point, the claim with the greatest effective amount is the controlling claim at this block.</p></li>
</ol>

<p>The purpose of 4 is to handle the case when multiple competing claims are made on the same name in different blocks, and one of those claims becomes active but another still-inactive claim has the greatest effective amount. Step 4 will cause the greater claim to also activate and become the controlling claim.</p>

<p>See the <a href="#claim-activation-example">example</a> in the appendix for more information.</p>

<h4 id="normalization">Normalization</h4>

<p>Names in the claimtrie are normalized when performing any comparisons. This is necessary to avoid confusion due to Unicode equivalence or casing. When names are being compared, they are first converted using <a href="http://unicode.org/reports/tr15/#Norm_Forms">Unicode Normalization Form D</a> (NFD), then lowercased using the en_US locale. This means names are effectively case-insensitive. Since claims competing for the same name are stored in the same node in the claimtrie, names are also normalized to determine the claimtrie path to the node.</p>

<h3 id="urls">URLs</h3>

<!-- fixme:
  jeremy: @grin does SPV need a mention inside of the document? 
  grin: no, but we should probably include an example for how to do the validation using the root hash. its not strictly necessary because its similar to how       bitcoin does it. so maybe link to https://lbry.tech/resources/claimtrie (which needs an update) and add a validation example there?
  -->

<p>URLs are memorable references to claims. All URLs:</p>

<ol>
<li>contain a name (see <a href="#claim-properties">Claim Properties</a>), and</li>
<li>resolve to a single, specific claim for that name</li>
</ol>

<p>The ultimate purpose of much of the claim and blockchain design is to provide memorable URLs that can be provably resolved by clients without a full copy of the blockchain (i.e. <a href="https://lbry.tech/glossary#spv">Simplified Payment Verification</a> wallets).</p>

<h4 id="components">Components</h4>

<p>A URL is a name with one or more modifiers. A bare name on its own resolves to the <a href="#controlling">controlling claim</a> at the latest block height. Here are some common URL structures.</p>

<h5 id="stream-claim-name">Stream Claim Name</h5>

<p>A controlling stream claim.</p>

<pre><code>lbry://meet-lbry
</code></pre>

<h5 id="channel-claim-name">Channel Claim Name</h5>

<p>A controlling channel claim.</p>

<pre><code>lbry://@lbry
</code></pre>

<h5 id="channel-claim-name-and-stream-claim-name">Channel Claim Name and Stream Claim Name</h5>

<p>A URL containing both a channel and a stream claim name. URLs containing both are resolved in two steps. First, the channel is resolved to it&rsquo;s associated claim. Then the stream claim name is resolved to get the appropriate claim from among the claims in the channel.</p>

<pre><code>lbry://@lbry/meet-lbry
</code></pre>

<h5 id="claim-id">Claim ID</h5>

<p>A claim for this name with this claim ID. Partial prefix matches are allowed (see <a href="#resolution">Resolution</a>).</p>

<pre><code>lbry://meet-lbry#7a0aa95c5023c21c098
lbry://meet-lbry#7a
lbry://@lbry#3f/meet-lbry
</code></pre>

<h5 id="claim-sequence">Claim Sequence</h5>

<p>The <em>n</em>th accepted claim for this name. <em>n</em> must be a positive number. This can be used to resolve claims in the order in which they were made, rather than by the amount of credits backing a claim.</p>

<pre><code>lbry://meet-lbry:1
lbry://@lbry:1/meet-lbry
</code></pre>

<h5 id="bid-position">Bid Position</h5>

<p>The <em>n</em>th claim for this name, ordered by total amount (highest first). <em>n</em> must be a positive number. This is useful for resolving non-winning bids in bid order.</p>

<pre><code>lbry://meet-lbry$2
lbry://meet-lbry$3
lbry://@lbry$2/meet-lbry
</code></pre>

<h5 id="query-params">Query Params</h5>

<p>These parameters have no meaning within the LBRY protocol. They are for use by upstream applications.</p>

<pre><code>lbry://meet-lbry?arg=value+arg2=value2
</code></pre>

<h4 id="grammar">Grammar</h4>

<p>The full URL grammar is defined using <a href="https://www.w3.org/TR/2017/REC-xquery-31-20170321/#EBNFNotation">Xquery EBNF notation</a>:</p>

<!-- use http://bottlecaps.de/rr/ui for visuals -->

<pre><code>URL ::= Scheme Path Query?

Scheme ::= 'lbry://'

Path ::=  StreamClaimNameAndModifier | ChannelClaimNameAndModifier ( '/' StreamClaimNameAndModifier )?

StreamClaimNameAndModifier ::= StreamClaimName Modifier?
ChannelClaimNameAndModifier ::= ChannelClaimName Modifier?

StreamClaimName ::= NameChar+
ChannelClaimName ::= '@' NameChar+

Modifier ::= ClaimID | ClaimSequence | BidPosition
ClaimID ::= '#' Hex+
ClaimSequence ::= ':' PositiveNumber
BidPosition ::= '$' PositiveNumber

Query ::= '?' QueryParameterList
QueryParameterList ::= QueryParameter ( '&amp;' QueryParameterList )*
QueryParameter ::= QueryParameterName ( '=' QueryParameterValue )?
QueryParameterName ::= NameChar+
QueryParameterValue ::= NameChar+

PositiveDigit ::= [123456789]
Digit ::= '0' | PositiveDigit
PositiveNumber ::= PositiveDigit Digit*

HexAlpha ::= [abcdef]
Hex ::= (Digit | HexAlpha)+

NameChar ::= Char - [=&amp;#:$@%?/]  /* any character that is not reserved */
Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF] /* any Unicode character, excluding the surrogate blocks, FFFE, and FFFF. */
</code></pre>

<h4 id="resolution">Resolution</h4>

<p>URL <em>resolution</em> is the process of translating a URL into the associated claim ID and metadata. Several URL components are described below. For more information, see the <a href="#url-resolution-examples">URL resolution example</a> in the appendix.</p>

<h5 id="no-modifier">No Modifier</h5>

<p>Return the controlling claim for the name. Stream claims and channel claims are resolved the same way.</p>

<h5 id="claimid">ClaimID</h5>

<p>Get all claims for the claim name whose IDs start with the given <code>ClaimID</code>. Sort the claims in ascending order by block height and position within the block. Return the first claim.</p>

<h5 id="claimsequence">ClaimSequence</h5>

<p>Get all claims for the claim name. Sort the claims in ascending order by block height and position within the block. Return the <em>n</em>th claim, where <em>n</em> is the given <code>ClaimSequence</code> value.</p>

<h5 id="bidposition">BidPosition</h5>

<p>Get all claims for the claim name. Sort the claims in descending order by total effective amount. Return the <em>n</em>th claim, where <em>n</em> is the given <code>BidSequence</code> value.</p>

<h5 id="channelclaimname-and-streamclaimname">ChannelClaimName and StreamClaimName</h5>

<p>If both a channel name and a stream name are present, resolution happens in two steps. First, remove the <code>/</code> and <code>StreamClaimNameAndModifier</code> from the path, and resolve the URL as if it only had a <code>ChannelClaimNameAndModifier</code>. Then get the list of all claims in that channel. Finally, resolve the <code>StreamClaimNameAndModifier</code> as if it was its own URL, but instead of considering all claims, only consider the set of claims in the channel.</p>

<p>If multiple claims for the same name exist inside the same channel, they are resolved via the same resolution rules applied entirely within the sub-scope of the channel.</p>

<h4 id="design-notes">Design Notes</h4>

<p>The most contentious aspect of this design is the choice to resolve names without modifiers (sometimes called <em>vanity names</em>) to the claim with the highest effective amount.</p>

<p>First, it is important to note the problems in existing name allocation designs. Most existing public name schemes are first-come, first-serve with a fixed price. This leads to several bad outcomes:</p>

<ol>
<li><p>Speculation and extortion. Entrepreneurs are incentivized to register common names even if they don&rsquo;t intend to use them, in hopes of selling them to the proper owner in the future for an exorbitant price. While speculation in general can have positive externalities (stable prices and price signals),  in this case it is pure value extraction. Speculation also harms the user experience, who will see the vast majority of URLs sitting unused (c.f. Namecoin).</p></li>

<li><p>Bureaucracy and transaction costs. While a centralized system can allow for an authority to use a process to reassign names based on trademark or other common use reasons, this system is also imperfect. Most importantly, it is a censorship point and an avenue for complete exclusion. Additionally, such processes are often arbitrary, change over time, involve significant transaction costs, and <em>still</em> lead to names being used in ways that are contrary to user expectation (e.g. <a href="http://nissan.com">nissan.com</a>).</p></li>

<li><p>Inefficiencies from price controls. Any system that does not allow a price to float freely creates inefficiencies. If the set price is too low, there is speculation and rent-seeking. If the price is too high, people are excluded from a good that it would otherwise be beneficial for them to purchase.</p></li>
</ol>

<p>Instead, LBRY has an algorithmic design built into consensus that encourage URLs to flow to their highest valued use. Following <a href="https://en.wikipedia.org/wiki/Coase_theorem">Coase</a>, this staking design allows for clearly defined rules, low transaction costs, and no information asymmetry, minimizing inefficiency in URL allocation.</p>

<p>Finally, it&rsquo;s important to note that <em>only</em> vanity URLs have this property. Permanent URLs that are short and memorable (like <code>lbry://myclaimname#a</code>) exist and are available for the minimal cost of issuing a transaction.</p>

<h3 id="transactions">Transactions</h3>

<p>The LBRY blockchain includes the following changes to Bitcoin&rsquo;s transaction scripting language.</p>

<h4 id="operations-and-opcodes">Operations and Opcodes</h4>

<p>To enable <a href="#claim-operations">claim operations</a>, three new opcodes were added to the scripting language: <code>OP_CLAIM_NAME</code>, <code>OP_UPDATE_CLAIM</code>, and <code>OP_SUPPORT_CLAIM</code>. In Bitcoin they are respectively <code>OP_NOP6</code>, <code>OP_NOP7</code>, and <code>OP_NOP8</code>. The opcodes are used in output scripts to interact with the claimtrie. Each opcode is followed by one or more parameters. Here&rsquo;s how these opcodes are used:</p>

<pre><code>OP_CLAIM_NAME &lt;name&gt; &lt;value&gt; OP_2DROP OP_DROP &lt;outputScript&gt;

OP_UPDATE_CLAIM &lt;name&gt; &lt;claimID&gt; &lt;value&gt; OP_2DROP OP_2DROP &lt;outputScript&gt;

OP_SUPPORT_CLAIM &lt;name&gt; &lt;claimID&gt; OP_2DROP OP_DROP &lt;outputScript&gt;
</code></pre>

<p>The <code>&lt;name&gt;</code> parameter is the [[name]] that the claim is associated with. <code>&lt;value&gt;</code> is the protobuf-encoded claim metadata and optional channel signature (see <a href="#metadata">Metadata</a> for more about this value). The <code>&lt;claimID&gt;</code> is the claim ID of a previous claim that is being updated or supported.</p>

<p>Each opcode will push a zero on to the execution stack. Those zeros, as well as any additional parameters after the opcodes, are all dropped by <code>OP_2DROP</code> and <code>OP_DROP</code>. <code>&lt;outputScript&gt;</code> can be any valid script, so a script using these opcodes is also a pay-to-pubkey script. This means that claim scripts can be spent just like regular Bitcoin output scripts.</p>

<h5 id="claim-identifier-generation">Claim Identifier Generation</h5>

<p>Like any standard Bitcoin output script, a claim script is associated with a transaction hash and output index. This combination of transaction hash and index is called an <em>outpoint</em>. Each claim script has a unique outpoint. The outpoint is hashed using SHA-256 and RIPEMD-160 to generate the claim ID for a claim. For the example above, let&rsquo;s say claim script is included in transaction <code>7560111513bea7ec38e2ce58a58c1880726b1515497515fd3f470d827669ed43</code> at the output index <code>1</code>. Then the claim ID is <code>529357c3422c6046d3fec76be2358004ba22e323</code>. An implementation of this is available <a href="https://github.com/lbryio/lbry.go/blob/master/lbrycrd/blockchain.go">here</a>.</p>

<h5 id="op-claim-name">OP_CLAIM_NAME</h5>

<p>New claims are created using <code>OP_CLAIM_NAME</code>. For example, a claim transaction setting the name <code>Fruit</code> to the value <code>Apple</code> looks like this:</p>

<pre><code>OP_CLAIM_NAME Fruit Apple OP_2DROP OP_DROP OP_DUP OP_HASH160 &lt;address&gt; OP_EQUALVERIFY OP_CHECKSIG
</code></pre>

<h5 id="op-update-claim">OP_UPDATE_CLAIM</h5>

<p><code>OP_UPDATE_CLAIM</code> updates a claim by replacing its metadata. An update transaction has an added requirement that it must spend the output for the existing claim that it wishes to update. Otherwise, it is considered invalid and will not make it into the claimtrie. Thus it must have the following redeem script:</p>

<pre><code>&lt;signature&gt; &lt;pubKeyForPreviousAddress&gt;
</code></pre>

<p>The syntax is identical to the standard way of redeeming a pay-to-pubkey script in Bitcoin, with the caveat that <code>&lt;pubKeyForPreviousAddress&gt;</code> must be the public key for the address of the output that contains the claim that is being updated.</p>

<p>To change the value of the previous example claim to “Banana”, the payout script is</p>

<pre><code>OP_UPDATE_CLAIM Fruit 529357c3422c6046d3fec76be2358004ba22e323 Banana OP_2DROP OP_2DROP OP_DUP OP_HASH160 &lt;address&gt; OP_EQUALVERIFY OP_CHECKSIG
</code></pre>

<p>The <code>&lt;address&gt;</code> in this script may be the same as the address in the original transaction, or it may be a new address.</p>

<h5 id="op-support-claim">OP_SUPPORT_CLAIM</h5>

<p>A support for the original example claim has the following payout script:</p>

<pre><code>OP_SUPPORT_CLAIM Fruit 529357c3422c6046d3fec76be2358004ba22e323 OP_2DROP OP_DROP OP_DUP OP_HASH160 &lt;address&gt; OP_EQUALVERIFY OP_CHECKSIG
</code></pre>

<p>The <code>&lt;address&gt;</code> in this script may be the same as the address in the original transaction, or it may be a new address.</p>

<h4 id="tips">Tips</h4>

<p>Since a claim is updated or abandoned by spending the claim&rsquo;s transaction, most claimtrie transactions spend to an address controlled by the transaction&rsquo;s creator. However, a claimtrie transaction can spend to any address. This can be used to create a <em>tip</em>. A tip is a support that also sends credits to the claim&rsquo;s creator. Tips in LBRY are just like tips in real life. They can be used to express gratitude or make an optional payment to a content creator.</p>

<h4 id="proof-of-payment">Proof of Payment</h4>

<!-- fixme -->

<p>TODO: Explain how transactions serve as proof that a client has made a valid payment for a piece of content.</p>

<h3 id="consensus">Consensus</h3>

<p>In addition to the stake-related changes described above, LBRY makes changes to the following blockchain consensus rules.</p>

<h4 id="block-timing">Block Timing</h4>

<p>The target block time was lowered from 10 minutes to 2.5 minutes to facilitate faster transaction confirmation.</p>

<h4 id="difficulty-adjustment">Difficulty Adjustment</h4>

<p>The proof-of-work target is adjusted every block to better adapt to sudden changes in hash rate. The exact adjustment algorithm can be seen <a href="https://github.com/lbryio/lbrycrd/blob/master/src/lbry.cpp">here</a>.</p>

<h4 id="block-hash-algorithm">Block Hash Algorithm</h4>

<p>LBRY uses a combination of SHA-256, SHA-512, and RIPEMD-160. The exact hashing algorithm can be seen <a href="https://github.com/lbryio/lbrycrd/blob/master/src/hash.cpp#L18">here</a>.</p>

<h4 id="block-rewards">Block Rewards</h4>

<p>The block reward schedule was adjusted to provide an initial testing period, a quick ramp-up to max block rewards, then a logarithmic decay to 0. The source for the algorithm is <a href="https://github.com/lbryio/lbrycrd/blob/master/src/main.cpp#L1594">here</a>.</p>

<h4 id="addresses">Addresses</h4>

<p>The address version byte is set to <code>0x55</code> for standard (pay-to-public-key-hash) addresses and <code>0x7a</code> for multisig (pay-to-script-hash) addresses. P2PKH addresses start with the letter <code>b</code>, and P2SH addresses start with <code>r</code>.</p>

<p>All the chain parameters are defined <a href="https://github.com/lbryio/lbrycrd/blob/master/src/chainparams.cpp">here</a>.</p>

<h2 id="metadata">Metadata</h2>

<p>Metadata is structured information about a stream or channel separate from the content itself (e.g. the title, language, media type, etc.). It is stored in the blockchain as the <a href="#claim-properties">value property</a> of a claim.</p>

<p>Metadata is stored in a serialized binary format using <a href="https://developers.google.com/protocol-buffers/">Protocol Buffers</a>. This allows for metadata to be:</p>

<ul>
<li><strong>Extensibile</strong>. Metadata can encompass thousands of fields for dozens of types of content. It must be efficient to both modify the structure and maintain backward compatibility.</li>
<li><strong>Compact</strong>. Blockchain space is expensive. Data must be stored as compactly as possible.</li>
<li><strong>Interoperabile</strong>. Metadata will be used by many projects written in different languages.</li>
</ul>

<p>The serialized metadata may be cryptographically signed to indicate membership in a channel. See <a href="#channels">Channels</a> for more info.</p>

<h3 id="specification">Specification</h3>

<p>The metadata specification is designed to grow and change frequently. The full specification is not detailed here. The <a href="https://github.com/lbryio/types">types</a> repository is considered the precise specification.</p>

<p>Instead, let&rsquo;s look at an example and some key fields.</p>

<h4 id="metadata-example">Example</h4>

<p>Here’s some example metadata:</p>

<pre><code>{
  &quot;stream&quot;: {
    &quot;title&quot;: &quot;What is LBRY?&quot;,
    &quot;author&quot;: &quot;Samuel Bryan&quot;,
    &quot;description&quot;: &quot;What is LBRY? An introduction with Alex Tabarrok&quot;,
    &quot;language&quot;: &quot;en&quot;,
    &quot;license&quot;: &quot;Public Domain&quot;,
    &quot;thumbnail&quot;: &quot;https://s3.amazonaws.com/files.lbry.io/logo.png&quot;,
    &quot;mediaType&quot;: &quot;video/mp4&quot;,
    &quot;streamHash&quot;: &quot;232068af6d51325c4821ac897d13d7837265812164021ec832cb7f18b9caf6c77c23016b31bac9747e7d5d9be7f4b752&quot;
  }
}
</code></pre>

<h3 id="key-fields">Key Fields</h3>

<p>Some important metadata fields are highlighted below.</p>

<h4 id="stream-hash">Stream Hash</h4>

<p>A unique identifier that is used to locate and fetch the content from the data network. More in <a href="#data">Data</a>.</p>

<h4 id="fee">Fee</h4>

<p>Information on how to pay for the content. It includes the address that will receive the payment (the <em>fee address</em>), the the amount to be paid, and the currency.</p>

<p>Example fee:</p>

<pre><code>&quot;fee&quot;: {
  &quot;address&quot;:&quot;bNz8Va7xMyK9eHA5APzLph6cCTjBtGgmDN&quot;,
  &quot;amount&quot;:&quot;99.95&quot;,
  &quot;currency&quot;:&quot;LBC&quot;
}
</code></pre>

<h4 id="title-author-description">Title, Author, Description</h4>

<p>Basic information about the stream.</p>

<h4 id="language">Language</h4>

<p>The <a href="https://www.iso.org/iso-639-language-codes.html">ISO 639-1</a> two-letter code for the language of the stream.</p>

<h4 id="thumbnail">Thumbnail</h4>

<p>A URL to be used to display an image associated with the content.</p>

<h4 id="media-type">Media Type</h4>

<p>The media type of the item as <a href="https://www.iana.org/assignments/media-types/media-types.xhtml">defined</a> by the IANA.</p>

<h3 id="channels">Channels (Identities)</h3>

<p>Channels are the unit of identity. A channel is a claim for a name beginning with <code>@</code> that contains a metadata structure for identity rather than content. Included in the metadata is the channel&rsquo;s public key. Here&rsquo;s an example:</p>

<pre><code>&quot;claimID&quot;: &quot;6e56325c5351ceda2dd0795a30e864492910ccbf&quot;,
&quot;name&quot;: &quot;@lbry&quot;,
&quot;amount&quot;: 6.26,
&quot;value&quot;: {
  &quot;channel&quot;: {
    &quot;keyType&quot;: &quot;SECP256k1&quot;,
    &quot;publicKey&quot;: &quot;3056301006072a8648ce3d020106052b8104000a03420004180488ffcb3d1825af538b0b952f0eba6933faa6d8229609ac0aeadfdbcf49C59363aa5d77ff2b7ff06cddc07116b335a4a0849b1b524a4a69d908d69f1bcebb&quot;
  }
}
</code></pre>

<p>Claims published to a channel contain a signature made with the corresponding private key. A valid signature proves channel membership.</p>

<p>The purpose of channels is to allow content to be clustered under a single pseudonym or identity. This allows publishers to easily list all their content, maintain attribution, and build their brand.</p>

<h4 id="signing">Signing</h4>

<p>A claim is considered part of a channel when its metadata is signed by the channel&rsquo;s private key. Here&rsquo;s the structure of a signed metadata value:</p>

<table>
<thead>
<tr>
<th align="left">field</th>
<th align="left">size</th>
<th align="left">description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">Version</td>
<td align="left">1 byte</td>
<td align="left">Format version. See <a href="#format-versions">Format Versions</a>.</td>
</tr>

<tr>
<td align="left">Channel ID</td>
<td align="left">20 bytes</td>
<td align="left">Claim ID of the channel claim that contains the matching public key. <em>Skip this field if there is no signature.</em></td>
</tr>

<tr>
<td align="left">Signature</td>
<td align="left">64 bytes</td>
<td align="left">The signature. <em>Skip this field if there is no signature.</em></td>
</tr>

<tr>
<td align="left">Payload</td>
<td align="left">variable</td>
<td align="left">The protobuf-encoded metadata.</td>
</tr>
</tbody>
</table>

<h5 id="format-versions">Format Versions</h5>

<p>The following formats are supported:</p>

<table>
<thead>
<tr>
<th align="left">format</th>
<th align="left">description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><code>00000000</code></td>
<td align="left">No signature.</td>
</tr>

<tr>
<td align="left"><code>00000001</code></td>
<td align="left">Signature using ECDSA SECP256k1 key and SHA-256 hash.</td>
</tr>
</tbody>
</table>

<h5 id="signing-process">Signing Process</h5>

<ol>
<li>Encode the metadata using protobuf.</li>
<li>Hash the encoded claim using SHA-256.</li>
<li>Sign the hash using the private key associated with the channel.</li>
<li>Append all the values (the version, the claim ID of the corresponding channel claim, the signature, and the protobuf-encoded metadata).</li>
</ol>

<h5 id="signature-validation">Signature Validation</h5>

<ol>
<li>Split out the version from the rest of the data.</li>
<li>Check the version field. If it indicates that there is no signature, then no validation is necessary.</li>
<li>Split out the channel ID and signature from the rest of the data.</li>
<li>Look up the channel claim to ensure it exists and contains a public key.</li>
<li>Use the public key to verify the signature.</li>
</ol>

<h3 id="metadata-validation">Validation</h3>

<p>No enforcement or validation on metadata happens at the blockchain level. Instead, metadata encoding, decoding, and validation is done by clients. This allows evolution of the metadata without changes to consensus rules. Clients are responsible for validating metadata, including data structure and signatures.</p>

<h2 id="data">Data</h2>

<p>Files published using LBRY are stored in a distributed fashion by the clients participating in the network. Each file is split into multiple small pieces. Each piece is encrypted and announced to the network. The pieces may also be uploaded to other hosts on the network that specialize in rehosting content.</p>

<p>The purpose of this process is to enable file storage and access without relying on centralized infrastructure, and to create a marketplace for data that allows hosts to be paid for their services. The design is strongly influenced by the Bittorrent protocol.</p>

<h3 id="encoding">Encoding</h3>

<p>Content on LBRY is encoded to facilitate distribution.</p>

<h4 id="blobs">Blobs</h4>

<p>The smallest unit of data is called a <em>blob</em>. A blob is an encrypted chunk of data up to 2MiB in size. Each blob is indexed by its <em>blob hash</em>, which is a SHA-384 hash of the blob. Addressing blobs by their hash protects against naming collisions and ensures that data cannot be accidentally or maliciously modified.</p>

<p>Blobs are encrypted using AES-256 in CBC mode and PKCS7 padding. In order to keep each encrypted blob at 2MiB max, a blob can hold at most 2097151 bytes (2MiB minus 1 byte) of plaintext data. The source code for the exact algorithm is available <a href="https://github.com/lbryio/lbry.go/blob/master/stream/blob.go">here</a>. The encryption key and initialization vector for each blob is stored as described below.</p>

<h4 id="streams">Streams</h4>

<p>Multiple blobs are combined into a <em>stream</em>. A stream may be a book, a movie, a CAD file, etc. All content on the network is shared as streams. Every stream begins with the <em>manifest blob</em>, followed by one or more <em>content blobs</em>. The content blobs hold the actual content of the stream. The manifest blob contains information necessary to find the content blobs and decode them into a file. This includes the hashes of the content blobs, their order in the stream, and cryptographic material for decrypting them.</p>

<p>The blob hash of the manifest blob is called the <em>stream hash</em>. It uniquely identifies each stream.</p>

<h4 id="manifest-contents">Manifest Contents</h4>

<p>A manifest blob&rsquo;s contents are encoded using <a href="http://wiki.laptop.org/go/Canonical_JSON">canonical JSON encoding</a>. The JSON encoding must be canonical to support consistent hashing and validation. Here&rsquo;s an example manifest:</p>

<!-- originally from 053b2f0f0e82e7f022837382733d5f5817dcd67027103fe43f00fa7a6f9fa8742c1022a851616c1ac15d1c60e89db3f4 -->

<pre><code>{&quot;blobs&quot;:[{&quot;blob_hash&quot;:&quot;a6daea71be2bb89fab29a2a10face08143411a5245edcaa5efff48c2e459e7ec01ad20edfde6da43a932aca45b2cec61&quot;,&quot;iv&quot;:&quot;ef6caef207a207ca5b14c0282d25ce21&quot;,&quot;length&quot;:2097152},{&quot;blob_hash&quot;:&quot;bf2717e2c445052366d35bcd58edb108cbe947af122d8f76b4856db577aeeaa2def5b57dbb80f7b1531296bd3e0256fc&quot;,&quot;iv&quot;:&quot;a37b291a37337fc1ff90ae655c244c1d&quot;,&quot;length&quot;:2097152},...,{&quot;blob_hash&quot;:&quot;322973617221ddfec6e53bff4b74b9c21c968cd32ba5a5094d84210e660c4b2ed0882b114a2392a08b06183f19330aaf&quot;,&quot;iv&quot;: &quot;a00f5f458695bdc9d50d3dbbc7905abc&quot;,&quot;length&quot;:600160}],&quot;filename&quot;:&quot;6b706a7977755477704d632e6d7034&quot;,&quot;key&quot;:&quot;94d89c0493c576057ac5f32eb0871180&quot;,&quot;version&quot;:1}
</code></pre>

<p>Here&rsquo;s the same manifest, with whitespace added for readability:</p>

<pre><code>{
  &quot;blobs&quot;:[
    {
      &quot;blobHash&quot;:&quot;a6daea71be2bb89fab29a2a10face08143411a5245edcaa5efff48c2e459e7ec01ad20edfde6da43a932aca45b2cec61&quot;,
      &quot;iv&quot;:&quot;ef6caef207a207ca5b14c0282d25ce21&quot;,
      &quot;length&quot;:2097152
    },
    {
      &quot;blobHash&quot;:&quot;bf2717e2c445052366d35bcd58edb108cbe947af122d8f76b4856db577aeeaa2def5b57dbb80f7b1531296bd3e0256fc&quot;,
      &quot;iv&quot;:&quot;a37b291a37337fc1ff90ae655c244c1d&quot;,
      &quot;length&quot;:2097152
    },
    ...,
    {
      &quot;blobHash&quot;:&quot;322973617221ddfec6e53bff4b74b9c21c968cd32ba5a5094d84210e660c4b2ed0882b114a2392a08b06183f19330aaf&quot;,
      &quot;iv&quot;: &quot;a00f5f458695bdc9d50d3dbbc7905abc&quot;,
      &quot;length&quot;: 600160
    }  
  ],
  &quot;filename&quot;:&quot;6b706a7977755477704d632e6d7034&quot;,
  &quot;key&quot;:&quot;94d89c0493c576057ac5f32eb0871180&quot;,
  &quot;version&quot;:1
}
</code></pre>

<p>The <code>blobs</code> field is an ordered list of blobs in the stream. Each item in the list has the blob hash for that blob, the hex-encoded initialization vector used to create the blob, and the length of the encrypted blob (not the original file chunk).</p>

<p>The <code>filename</code> is the hex-encoded name of the original file.</p>

<p>The <code>key</code> field contains the hex-encoded <em>stream key</em>, which is used to decrypt the blobs in the stream. This field is optional. The stream key may instead be stored by a third party and made available to a client when presented with proof that the content was purchased.</p>

<p>The <code>version</code> field is always 1. It is intended to signal structure changes in future versions of this protocol.</p>

<p>Every stream must have at least two blobs - the manifest blob and a content blob. Consequently, zero-length streams are not allowed.</p>

<h4 id="stream-encoding">Stream Encoding</h4>

<p>A file must be encoded into a stream before it can be published. Encoding involves breaking the file into chunks, encrypting the chunks into content blobs, and creating the manifest blob. Here are the steps:</p>

<h5 id="setup">Setup</h5>

<ol>
<li>Generate a random 32-byte stream key. This key will be used to encrypt each content blob in the stream.</li>
</ol>

<h5 id="content-blobs">Content Blobs</h5>

<ol>
<li>Break the file into chunks of at most 2097151 bytes.</li>
<li>Generate a random 32-byte initialization vector (IV) for each chuck.</li>
<li>Pad each chunk using PKCS7 padding.</li>
<li>Encrypt each chunk with AES-CBC using the stream key and the IV for that chunk.</li>
<li>An encrypted chunk is a blob.</li>
</ol>

<h5 id="manifest-blob">Manifest Blob</h5>

<ol>
<li>Fill in the manifest data as described in the <a href="#manifest-contents">Manifest Contents</a>.</li>
<li>Encode the data using the canonical JSON encoding.</li>
<li>Compute the stream hash.</li>
</ol>

<p>An implementation of this process is available <a href="https://github.com/lbryio/lbry.go/tree/master/stream">here</a>.</p>

<!-- fixme: the above link is for v0, not v1. need to implement v1 or drop the link. -->

<h4 id="stream-decoding">Stream Decoding</h4>

<p>Decoding a stream is like encoding in reverse, and with the added step of verifying that the expected blob hashes match the actual data.</p>

<ol>
<li>Verify that the hash of the manifest blob and matches the stream hash.</li>
<li>Parse the JSON in manifest blob.</li>
<li>Verify the hashes of the content blobs.</li>
<li>Decrypt and remove the padding from each content blob using the stream key and IVs in the manifest.</li>
<li>Concatenate the decrypted chunks in order.</li>
</ol>

<h3 id="announce">Announce</h3>

<p>After a [[stream]] is encoded, it must be <em>announced</em> to the network. Announcing is the process of letting other nodes on the network know that a client has content available for download. LBRY tracks announced content using a distributed hash table.</p>

<h4 id="distributed-hash-table">Distributed Hash Table</h4>

<p><em>Distributed hash tables</em> (or DHTs) are an effective way to build a decentralized content network. Our DHT implementation follows the <a href="https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf">Kademlia</a>
specification fairly closely, with some modifications.</p>

<p>A distributed hash table is a key-value store that is spread over multiple nodes in a network. Nodes may join or leave the network anytime, with no central coordination necessary. Nodes communicate with each other using a peer-to-peer protocol to advertise what data they have and what they are best positioned to store.</p>

<p>When a host connects to the DHT, it announces the hash for every [[blob]] it wishes to share. Downloading a blob from the network requires querying the DHT for a list of hosts that announced that blob’s hash (called <em>peers</em>), then requesting the blob from the peers directly.</p>

<h4 id="announcing-to-the-dht">Announcing to the DHT</h4>

<p>A host announces a hash to the DHT in two steps. First, the host looks for nodes that are closest to the target hash. Then the host asks those nodes to store the fact that the host has the target hash available for download.</p>

<p>Finding the closest nodes is done via iterative <code>FindNode</code> DHT requests. The host starts with the closest nodes it knows about and sends a <code>FindNode(target_hash)</code> request to each of them. If any of the requests return nodes that are closer to the target hash, the host sends <code>FindNode</code> requests to those nodes to try to get even closer. When the <code>FindNode</code> requests no longer return nodes that are closer, the search ends.</p>

<p>Once the search is over, the host sends a <code>Store(target_hash)</code> request to the closest several nodes it found. The nodes receiving this request store the fact that the host is a peer for the target hash.</p>

<h3 id="download">Download</h3>

<p>A client wishing to download a [[stream]] must first query the [[DHT]] to find [[peers]] hosting the [[blobs]] in that stream, then contact those peers to download the blobs directly.</p>

<h4 id="querying-the-dht">Querying the DHT</h4>

<p>Querying works almost the same way as [[announcing]]. A client looking for a target hash starts by sending iterative <code>FindValue(target_hash)</code> requests to the nodes it knows that are closest to the target hash. If a node receives a <code>FindValue</code> request and knows of any peers for the target hash, it responds with a list of those peers. Otherwise, it responds with the closest nodes to the target hash that it knows about. The client then queries those closer nodes using the same <code>FindValue</code> call. This way, each call either finds the client some peers, or brings it closer to finding those peers. If no peers are found and no closer nodes are being returned, the client determines that the target hash is not available and gives up.</p>

<h4 id="blob-exchange-protocol">Blob Exchange Protocol</h4>

<p>Downloading a blob from a peer is governed by the <em>Blob Exchange Protocol</em>. It is used by hosts and clients to exchange blobs and check data pricing and blob availability. The protocol is an RPC protocol using Protocol Buffers and the gRPC framework. It has five types of requests.</p>

<h5 id="pricecheck">PriceCheck</h5>

<p>PriceCheck gets the price that the server is charging for data transfer. It returns the prices in [[deweys]] per KB.</p>

<h5 id="downloadcheck">DownloadCheck</h5>

<p>DownloadCheck checks whether the server has certain blobs available for download. For each hash in the request, the server returns a true or false to indicate whether the blob is available.</p>

<h5 id="download-1">Download</h5>

<p>Download requests the blob for a given hash. The response contains the blob, its hash, and the address where to send payment for the data transfer. If the blob is not available on the server, the response instead contains an error.</p>

<h5 id="uploadcheck">UploadCheck</h5>

<p>UploadCheck asks the server whether blobs can be uploaded to it. For each hash in the request, the server returns a true or false to indicate whether it would accept a given blob for upload. In addition, if any of the hashes in the request is a stream hash and the server has the manifest blob for that stream but is missing some content blobs, it may include the hashes of those content blobs in the response.</p>

<h5 id="upload">Upload</h5>

<p>Upload sends a blob to the server. If uploading many blobs, the client should use the UploadCheck request to check which blobs the server actually needs. This avoids needlessly uploading blobs that the server already has. If a client tries to upload too many blobs that the server does not want, this may be consider a denial of service attack.</p>

<p>The protocol calls and message types are defined in detail <a href="https://github.com/lbryio/lbry.go/blob/master/blobex/blobex.proto">here</a>.</p>

<h3 id="reflectors-and-data-markets">Reflectors and Data Markets</h3>

<p>In order for a client to download content, there must be hosts online that have the content the client wants, when the client wants it. To incentivize the continued hosting of data, the blob exchange protocol supports data upload and payment for data. <em>Reflectors</em> are hosts that accept data uploads. They rehost (reflect) the uploaded data and charge for downloads. Using a reflector is optional, but most publishers will probably choose to use them. Doing so obviates the need for the publisher&rsquo;s server to be online and connectable, which can be especially useful for mobile clients or those behind a firewall.</p>

<p>The current version of the protocol does not support sophisticated price negotiation between clients and hosts. The host simply chooses the price it wants to charge. Clients check this price before downloading, and pay the price after the download is complete. Future protocol versions will include more options for price negotiation, as well as stronger proofs of payment.</p>

<h2 id="appendix">Appendix</h2>

<h3 id="claim-activation-example">Claim Activation Example</h3>

<p>Here is a step-by-step example to illustrate how competing claims activate and are ordered. All stakes are for the same name.</p>

<p><strong>Block 13:</strong> Claim A for 10LBC is accepted. It is the first claim, so it immediately becomes active and controlling.
<br>State: A(10) is controlling</p>

<p><strong>Block 1001:</strong> Claim B for 20LBC is accepted. It’s activation height is <code>1001 + min(4032, floor((1001-13) / 32)) = 1001 + 30 = 1031</code>.
<br>State: A(10) is controlling, B(20) is accepted.</p>

<p><strong>Block 1010:</strong> Support X for 14LBC for claim A is accepted. Since it is a support for the controlling claim, it activates immediately.
<br>State: A(10+14) is controlling, B(20) is accepted.</p>

<p><strong>Block 1020:</strong> Claim C for 50LBC is accepted. The activation height is <code>1020 + min(4032, floor((1020-13) / 32)) = 1020 + 31 = 1051</code>.
<br>State: A(10+14) is controlling, B(20) is accepted, C(50) is accepted.</p>

<p><strong>Block 1031:</strong> Claim B activates. It has 20LBC, while claim A has 24LBC (10 original + 14 from support X). There is no takeover, and claim A remains controlling.
<br>State: A(10+14) is controlling, B(20) is active, C(50) is accepted.</p>

<p><strong>Block 1040:</strong> Claim D for 300LBC is accepted. The activation height is <code>1040 + min(4032, floor((1040-13) / 32)) = 1040 + 32 = 1072</code>.
<br>State: A(10+14) is controlling, B(20) is active, C(50) is accepted, D(300) is accepted.</p>

<p><strong>Block 1051:</strong> Claim C activates. It has 50LBC, while claim A has 24LBC, so a takeover is initiated. The takeover height for this name is set to 1051, and therefore the activation delay for all the claims becomes <code>min(4032, floor((1051-1051) / 32)) = 0</code>. All the claims become active. The totals for each claim are recalculated, and claim D becomes controlling because it has the highest total.
<br>State: A(10+14) is active, B(20) is active, C(50) is active, D(300) is controlling.</p>

<h3 id="url-resolution-examples">URL Resolution Examples</h3>

<p>Suppose the following names were claimed in the following order and no other claims exist.</p>

<table>
<thead>
<tr>
<th align="left">Channel Name</th>
<th align="left">Stream Name</th>
<th align="left">Claim ID</th>
<th align="left">Amount</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><em>&ndash;</em></td>
<td align="left">apple</td>
<td align="left">690eea</td>
<td align="left">1</td>
</tr>

<tr>
<td align="left"><em>&ndash;</em></td>
<td align="left">banana</td>
<td align="left">714a3f</td>
<td align="left">2</td>
</tr>

<tr>
<td align="left"><em>&ndash;</em></td>
<td align="left">cherry</td>
<td align="left">bfaabb</td>
<td align="left">100</td>
</tr>

<tr>
<td align="left"><em>&ndash;</em></td>
<td align="left">apple</td>
<td align="left">690eea</td>
<td align="left">10</td>
</tr>

<tr>
<td align="left">@Arthur</td>
<td align="left"><em>&ndash;</em></td>
<td align="left">b7bab5</td>
<td align="left">1</td>
</tr>

<tr>
<td align="left">@Bryan</td>
<td align="left"><em>&ndash;</em></td>
<td align="left">0da517</td>
<td align="left">1</td>
</tr>

<tr>
<td align="left">@Chris</td>
<td align="left"><em>&ndash;</em></td>
<td align="left">b3f7b1</td>
<td align="left">1</td>
</tr>

<tr>
<td align="left">@Chris</td>
<td align="left">banana</td>
<td align="left">fc861c</td>
<td align="left">1</td>
</tr>

<tr>
<td align="left">@Arthur</td>
<td align="left">apple</td>
<td align="left">37ee1</td>
<td align="left">20</td>
</tr>

<tr>
<td align="left">@Bryan</td>
<td align="left">cherry</td>
<td align="left">a18bca</td>
<td align="left">10</td>
</tr>

<tr>
<td align="left">@Chris</td>
<td align="left"><em>&ndash;</em></td>
<td align="left">005a7d</td>
<td align="left">100</td>
</tr>

<tr>
<td align="left">@Arthur</td>
<td align="left">cherry</td>
<td align="left">d39aa0</td>
<td align="left">20</td>
</tr>
</tbody>
</table>
<p>Here is how the following URLs resolve:</p>

<table>
<thead>
<tr>
<th align="left">URL</th>
<th align="left">Claim ID</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><code>lbry://apple</code></td>
<td align="left">a37ee1</td>
</tr>

<tr>
<td align="left"><code>lbry://banana</code></td>
<td align="left">714a3f</td>
</tr>

<tr>
<td align="left"><code>lbry://@Chris</code></td>
<td align="left">005a7d</td>
</tr>

<tr>
<td align="left"><code>lbry://@Chris/banana</code></td>
<td align="left"><em>not found</em> (the controlling <code>@Chris</code> does not have a <code>banana</code>)</td>
</tr>

<tr>
<td align="left"><code>lbry://@Chris:1/banana</code></td>
<td align="left">fc861c</td>
</tr>

<tr>
<td align="left"><code>lbry://@Chris:#fc8/banana</code></td>
<td align="left">fc861c</td>
</tr>

<tr>
<td align="left"><code>lbry://cherry</code></td>
<td align="left">bfaabb</td>
</tr>

<tr>
<td align="left"><code>lbry://@Arthur/cherry</code></td>
<td align="left">d39aa0</td>
</tr>

<tr>
<td align="left"><code>lbry://@Bryan</code></td>
<td align="left">0da517</td>
</tr>

<tr>
<td align="left"><code>lbry://banana$1</code></td>
<td align="left">714a3f</td>
</tr>

<tr>
<td align="left"><code>lbry://banana$2</code></td>
<td align="left">fc861c</td>
</tr>

<tr>
<td align="left"><code>lbry://banana$3</code></td>
<td align="left"><em>not found</em></td>
</tr>

<tr>
<td align="left"><code>lbry://@Arthur:1</code></td>
<td align="left">b7bab5</td>
</tr>
</tbody>
</table>

<pre style="font: 10px/5px monospace;overflow:hidden;text-align: center;margin: 10rem 0">
                                                                                           
                                             ++                                            
                                           :+++++                                          
                                          +++++++++                                        
                                        '++++++++++++`                                     
                                      .++++++',++++++++`                                   
                                     +++++++    .++++++++.                                 
                                   ;++++++:       `++++++++,                               
                                  +++++++            ++++++++,                             
                                +++++++`               ++++++++:                           
                              ,++++++'                   ++++++++;                         
                             +++++++                       ++++++++'                       
                           '++++++,                          ++++++++'                     
                         `+++++++                              '++++++++                   
                        +++++++                                  '++++++++                 
                      :++++++;                                     ;++++++++               
                     +++++++                                         :++++++++             
                   '++++++.                                            ,++++++++           
                 .++++++'                                                ,++++++++`        
                +++++++                                                    .++++++++`      
              ;++++++,                                                       `+++++++      
            `+++++++                                                           `+++++      
           +++++++`                                                              ++++      
         :++++++;                                                               +++++      
        +++++++                                                               ,++++++      
      '++++++.                                                               +++++++       
    .++++++'                                                               '++++++,        
   +++++++                                                               `+++++++          
   +++++:                                                               +++++++            
   ++++                                                               ;++++++:             
   ++++                                                              +++++++               
   ++++      ++                                                    +++++++`                
   ++++      ++++                                                ,++++++'             .:   
   ++++      ++++++                                             +++++++     :'++++++++++   
   ++++      ++++++++                                         '++++++.       ++++++++++    
   ++++       :++++++++                                     .++++++'         .+++++++++    
   ++++         :++++++++                                  +++++++            ++++++++.    
   ++++           ,++++++++                              ;++++++:            :++++++++     
   ++++             ,++++++++                          `+++++++             +++++++++,     
   ++++               ,++++++++                       +++++++`            +++++++++++      
   +++++.               .++++++++`                  :++++++;            ,+++++++ +++;      
   +++++++.               .++++++++`               +++++++             +++++++    ++       
    ++++++++,               `++++++++`           '++++++.            '++++++:     ,'       
      ++++++++,               `++++++++`       .++++++'            .+++++++                
        ++++++++,               `++++++++.    +++++++             +++++++`                 
          ++++++++,                ++++++++.'++++++,            ;++++++;                   
            ++++++++:                +++++++++++++            `+++++++                     
              ++++++++:                +++++++++`            +++++++.                      
                ++++++++:                +++++;            ,++++++'                        
                  ++++++++:                ++             +++++++                          
                    ++++++++;                           '++++++,                           
                      '+++++++;                       .+++++++                             
                        '+++++++;                    +++++++                               
                          '+++++++;                ;++++++:                                
                            '+++++++'            `+++++++                                  
                              '+++++++'         +++++++`                                   
                                '+++++++'     :++++++;                                     
                                  ;+++++++'  +++++++                                       
                                    ;+++++++++++++.                                        
                                      ;+++++++++'                                          
                                        ;++++++                                            
                                          :++,                                             

</pre>

<hr>

<p><em>Edit this on Github at <a href="https://github.com/lbryio/spec">https://github.com/lbryio/spec</a></em></p>

<p></div></main> <!-- DONT DELETE THIS, its for the TOC --></p>

<script src="https://hypothes.is/embed.js" async></script>

</body>
</html>

